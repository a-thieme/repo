// Code generated by ndn tlv codegen DO NOT EDIT.
package tlv

import (
	"encoding/binary"
	"io"
	"strings"

	enc "github.com/named-data/ndnd/std/encoding"
)

type CommandEncoder struct {
	Length uint

	Target_length uint
}

type CommandParsingContext struct {
}

func (encoder *CommandEncoder) Init(value *Command) {

	if value.Target != nil {
		encoder.Target_length = 0
		for _, c := range value.Target {
			encoder.Target_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	l += 3
	l += uint(enc.TLNum(len(value.Type)).EncodingLength())
	l += uint(len(value.Type))
	if value.Target != nil {
		l += 3
		l += uint(enc.TLNum(encoder.Target_length).EncodingLength())
		l += encoder.Target_length
	}
	l += 3
	l += uint(1 + enc.Nat(value.SnapshotThreshold).EncodingLength())
	encoder.Length = l

}

func (context *CommandParsingContext) Init() {

}

func (encoder *CommandEncoder) EncodeInto(value *Command, buf []byte) {

	pos := uint(0)

	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(594))
	pos += 3
	pos += uint(enc.TLNum(len(value.Type)).EncodeInto(buf[pos:]))
	copy(buf[pos:], value.Type)
	pos += uint(len(value.Type))
	if value.Target != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(595))
		pos += 3
		pos += uint(enc.TLNum(encoder.Target_length).EncodeInto(buf[pos:]))
		for _, c := range value.Target {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(597))
	pos += 3

	buf[pos] = byte(enc.Nat(value.SnapshotThreshold).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
}

func (encoder *CommandEncoder) Encode(value *Command) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *CommandParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*Command, error) {

	var handled_Type bool = false
	var handled_Target bool = false
	var handled_SnapshotThreshold bool = false

	progress := -1
	_ = progress

	value := &Command{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 594:
				if true {
					handled = true
					handled_Type = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int(l))
						if err == nil {
							value.Type = builder.String()
						}
					}
				}
			case 595:
				if true {
					handled = true
					handled_Target = true
					delegate := reader.Delegate(int(l))
					value.Target, err = delegate.ReadName()
				}
			case 597:
				if true {
					handled = true
					handled_SnapshotThreshold = true
					value.SnapshotThreshold = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.SnapshotThreshold = uint64(value.SnapshotThreshold<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Type && err == nil {
		err = enc.ErrSkipRequired{Name: "Type", TypeNum: 594}
	}
	if !handled_Target && err == nil {
		value.Target = nil
	}
	if !handled_SnapshotThreshold && err == nil {
		err = enc.ErrSkipRequired{Name: "SnapshotThreshold", TypeNum: 597}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *Command) Encode() enc.Wire {
	encoder := CommandEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *Command) Bytes() []byte {
	return value.Encode().Join()
}

func ParseCommand(reader enc.WireView, ignoreCritical bool) (*Command, error) {
	context := CommandParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type InternalCommandEncoder struct {
	Length uint

	Target_length uint
}

type InternalCommandParsingContext struct {
}

func (encoder *InternalCommandEncoder) Init(value *InternalCommand) {

	if value.Target != nil {
		encoder.Target_length = 0
		for _, c := range value.Target {
			encoder.Target_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	l += 3
	l += uint(enc.TLNum(len(value.Type)).EncodingLength())
	l += uint(len(value.Type))
	if value.Target != nil {
		l += 3
		l += uint(enc.TLNum(encoder.Target_length).EncodingLength())
		l += encoder.Target_length
	}
	l += 3
	l += uint(1 + enc.Nat(value.SnapshotThreshold).EncodingLength())
	l += 3
	l += uint(1 + enc.Nat(value.StorageSpace).EncodingLength())
	encoder.Length = l

}

func (context *InternalCommandParsingContext) Init() {

}

func (encoder *InternalCommandEncoder) EncodeInto(value *InternalCommand, buf []byte) {

	pos := uint(0)

	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(594))
	pos += 3
	pos += uint(enc.TLNum(len(value.Type)).EncodeInto(buf[pos:]))
	copy(buf[pos:], value.Type)
	pos += uint(len(value.Type))
	if value.Target != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(595))
		pos += 3
		pos += uint(enc.TLNum(encoder.Target_length).EncodeInto(buf[pos:]))
		for _, c := range value.Target {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(597))
	pos += 3

	buf[pos] = byte(enc.Nat(value.SnapshotThreshold).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(660))
	pos += 3

	buf[pos] = byte(enc.Nat(value.StorageSpace).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
}

func (encoder *InternalCommandEncoder) Encode(value *InternalCommand) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *InternalCommandParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*InternalCommand, error) {

	var handled_Type bool = false
	var handled_Target bool = false
	var handled_SnapshotThreshold bool = false
	var handled_StorageSpace bool = false

	progress := -1
	_ = progress

	value := &InternalCommand{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 594:
				if true {
					handled = true
					handled_Type = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int(l))
						if err == nil {
							value.Type = builder.String()
						}
					}
				}
			case 595:
				if true {
					handled = true
					handled_Target = true
					delegate := reader.Delegate(int(l))
					value.Target, err = delegate.ReadName()
				}
			case 597:
				if true {
					handled = true
					handled_SnapshotThreshold = true
					value.SnapshotThreshold = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.SnapshotThreshold = uint64(value.SnapshotThreshold<<8) | uint64(x)
						}
					}
				}
			case 660:
				if true {
					handled = true
					handled_StorageSpace = true
					value.StorageSpace = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.StorageSpace = uint64(value.StorageSpace<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Type && err == nil {
		err = enc.ErrSkipRequired{Name: "Type", TypeNum: 594}
	}
	if !handled_Target && err == nil {
		value.Target = nil
	}
	if !handled_SnapshotThreshold && err == nil {
		err = enc.ErrSkipRequired{Name: "SnapshotThreshold", TypeNum: 597}
	}
	if !handled_StorageSpace && err == nil {
		err = enc.ErrSkipRequired{Name: "StorageSpace", TypeNum: 660}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *InternalCommand) Encode() enc.Wire {
	encoder := InternalCommandEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *InternalCommand) Bytes() []byte {
	return value.Encode().Join()
}

func ParseInternalCommand(reader enc.WireView, ignoreCritical bool) (*InternalCommand, error) {
	context := InternalCommandParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type StatusResponseEncoder struct {
	Length uint

	Target_length uint
}

type StatusResponseParsingContext struct {
}

func (encoder *StatusResponseEncoder) Init(value *StatusResponse) {
	if value.Target != nil {
		encoder.Target_length = 0
		for _, c := range value.Target {
			encoder.Target_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	if value.Target != nil {
		l += 3
		l += uint(enc.TLNum(encoder.Target_length).EncodingLength())
		l += encoder.Target_length
	}
	l += 3
	l += uint(enc.TLNum(len(value.Status)).EncodingLength())
	l += uint(len(value.Status))
	encoder.Length = l

}

func (context *StatusResponseParsingContext) Init() {

}

func (encoder *StatusResponseEncoder) EncodeInto(value *StatusResponse, buf []byte) {

	pos := uint(0)

	if value.Target != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(640))
		pos += 3
		pos += uint(enc.TLNum(encoder.Target_length).EncodeInto(buf[pos:]))
		for _, c := range value.Target {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(641))
	pos += 3
	pos += uint(enc.TLNum(len(value.Status)).EncodeInto(buf[pos:]))
	copy(buf[pos:], value.Status)
	pos += uint(len(value.Status))
}

func (encoder *StatusResponseEncoder) Encode(value *StatusResponse) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *StatusResponseParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*StatusResponse, error) {

	var handled_Target bool = false
	var handled_Status bool = false

	progress := -1
	_ = progress

	value := &StatusResponse{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 640:
				if true {
					handled = true
					handled_Target = true
					delegate := reader.Delegate(int(l))
					value.Target, err = delegate.ReadName()
				}
			case 641:
				if true {
					handled = true
					handled_Status = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int(l))
						if err == nil {
							value.Status = builder.String()
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Target && err == nil {
		value.Target = nil
	}
	if !handled_Status && err == nil {
		err = enc.ErrSkipRequired{Name: "Status", TypeNum: 641}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *StatusResponse) Encode() enc.Wire {
	encoder := StatusResponseEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *StatusResponse) Bytes() []byte {
	return value.Encode().Join()
}

func ParseStatusResponse(reader enc.WireView, ignoreCritical bool) (*StatusResponse, error) {
	context := StatusResponseParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type NodeUpdateEncoder struct {
	Length uint

	Jobs_subencoder []struct {
		Jobs_length uint
	}
	NewCommand_encoder CommandEncoder

	JobRelease_encoder InternalCommandEncoder
}

type NodeUpdateParsingContext struct {
	NewCommand_context CommandParsingContext

	JobRelease_context InternalCommandParsingContext
}

func (encoder *NodeUpdateEncoder) Init(value *NodeUpdate) {
	{
		Jobs_l := len(value.Jobs)
		encoder.Jobs_subencoder = make([]struct {
			Jobs_length uint
		}, Jobs_l)
		for i := 0; i < Jobs_l; i++ {
			pseudoEncoder := &encoder.Jobs_subencoder[i]
			pseudoValue := struct {
				Jobs enc.Name
			}{
				Jobs: value.Jobs[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Jobs != nil {
					encoder.Jobs_length = 0
					for _, c := range value.Jobs {
						encoder.Jobs_length += uint(c.EncodingLength())
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.NewCommand != nil {
		encoder.NewCommand_encoder.Init(value.NewCommand)
	}

	if value.JobRelease != nil {
		encoder.JobRelease_encoder.Init(value.JobRelease)
	}

	l := uint(0)
	if value.Jobs != nil {
		for seq_i, seq_v := range value.Jobs {
			pseudoEncoder := &encoder.Jobs_subencoder[seq_i]
			pseudoValue := struct {
				Jobs enc.Name
			}{
				Jobs: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Jobs != nil {
					l += 3
					l += uint(enc.TLNum(encoder.Jobs_length).EncodingLength())
					l += encoder.Jobs_length
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.NewCommand != nil {
		l += 3
		l += uint(enc.TLNum(encoder.NewCommand_encoder.Length).EncodingLength())
		l += encoder.NewCommand_encoder.Length
	}
	l += 3
	l += uint(1 + enc.Nat(value.StorageCapacity).EncodingLength())
	l += 3
	l += uint(1 + enc.Nat(value.StorageUsed).EncodingLength())
	if value.JobRelease != nil {
		l += 3
		l += uint(enc.TLNum(encoder.JobRelease_encoder.Length).EncodingLength())
		l += encoder.JobRelease_encoder.Length
	}
	encoder.Length = l

}

func (context *NodeUpdateParsingContext) Init() {

	context.NewCommand_context.Init()

	context.JobRelease_context.Init()
}

func (encoder *NodeUpdateEncoder) EncodeInto(value *NodeUpdate, buf []byte) {

	pos := uint(0)

	if value.Jobs != nil {
		for seq_i, seq_v := range value.Jobs {
			pseudoEncoder := &encoder.Jobs_subencoder[seq_i]
			pseudoValue := struct {
				Jobs enc.Name
			}{
				Jobs: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Jobs != nil {
					buf[pos] = 253
					binary.BigEndian.PutUint16(buf[pos+1:], uint16(656))
					pos += 3
					pos += uint(enc.TLNum(encoder.Jobs_length).EncodeInto(buf[pos:]))
					for _, c := range value.Jobs {
						pos += uint(c.EncodeInto(buf[pos:]))
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.NewCommand != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(657))
		pos += 3
		pos += uint(enc.TLNum(encoder.NewCommand_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.NewCommand_encoder.Length > 0 {
			encoder.NewCommand_encoder.EncodeInto(value.NewCommand, buf[pos:])
			pos += encoder.NewCommand_encoder.Length
		}
	}
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(658))
	pos += 3

	buf[pos] = byte(enc.Nat(value.StorageCapacity).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(659))
	pos += 3

	buf[pos] = byte(enc.Nat(value.StorageUsed).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if value.JobRelease != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(660))
		pos += 3
		pos += uint(enc.TLNum(encoder.JobRelease_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.JobRelease_encoder.Length > 0 {
			encoder.JobRelease_encoder.EncodeInto(value.JobRelease, buf[pos:])
			pos += encoder.JobRelease_encoder.Length
		}
	}
}

func (encoder *NodeUpdateEncoder) Encode(value *NodeUpdate) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *NodeUpdateParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*NodeUpdate, error) {

	var handled_Jobs bool = false
	var handled_NewCommand bool = false
	var handled_StorageCapacity bool = false
	var handled_StorageUsed bool = false
	var handled_JobRelease bool = false

	progress := -1
	_ = progress

	value := &NodeUpdate{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 656:
				if true {
					handled = true
					handled_Jobs = true
					if value.Jobs == nil {
						value.Jobs = make([]enc.Name, 0)
					}
					{
						pseudoValue := struct {
							Jobs enc.Name
						}{}
						{
							value := &pseudoValue
							delegate := reader.Delegate(int(l))
							value.Jobs, err = delegate.ReadName()
							_ = value
						}
						value.Jobs = append(value.Jobs, pseudoValue.Jobs)
					}
					progress--
				}
			case 657:
				if true {
					handled = true
					handled_NewCommand = true
					value.NewCommand, err = context.NewCommand_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 658:
				if true {
					handled = true
					handled_StorageCapacity = true
					value.StorageCapacity = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.StorageCapacity = uint64(value.StorageCapacity<<8) | uint64(x)
						}
					}
				}
			case 659:
				if true {
					handled = true
					handled_StorageUsed = true
					value.StorageUsed = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.StorageUsed = uint64(value.StorageUsed<<8) | uint64(x)
						}
					}
				}
			case 660:
				if true {
					handled = true
					handled_JobRelease = true
					value.JobRelease, err = context.JobRelease_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Jobs && err == nil {
		// sequence - skip
	}
	if !handled_NewCommand && err == nil {
		value.NewCommand = nil
	}
	if !handled_StorageCapacity && err == nil {
		err = enc.ErrSkipRequired{Name: "StorageCapacity", TypeNum: 658}
	}
	if !handled_StorageUsed && err == nil {
		err = enc.ErrSkipRequired{Name: "StorageUsed", TypeNum: 659}
	}
	if !handled_JobRelease && err == nil {
		value.JobRelease = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *NodeUpdate) Encode() enc.Wire {
	encoder := NodeUpdateEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *NodeUpdate) Bytes() []byte {
	return value.Encode().Join()
}

func ParseNodeUpdate(reader enc.WireView, ignoreCritical bool) (*NodeUpdate, error) {
	context := NodeUpdateParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
